Паттерн "Адаптер" (Adapter) и паттерн "Декоратор" (Decorator) — это два различных паттерна проектирования, каждый из которых решает свои задачи.

### Паттерн "Адаптер"

**Описание:**
Паттерн "Адаптер" используется для обеспечения взаимодействия между двумя несовместимыми интерфейсами. Он позволяет объектам с несовместимыми интерфейсами работать вместе, предоставляя адаптер, который преобразует интерфейс одного объекта в интерфейс, ожидаемый клиентом.

**Пример реализации:**

Предположим, у нас есть сторонняя библиотека, которая предоставляет функционал работы с геометрическими фигурами через интерфейс `Shape`:

```java
// Сторонняя библиотека
public interface Shape {
    void draw();
}
```

Наш клиентский код ожидает работать с интерфейсом `Shape`:

```java
// Клиентский код
public class Client {
    private Shape shape;

    public Client(Shape shape) {
        this.shape = shape;
    }

    public void execute() {
        shape.draw();
    }
}
```

Теперь, допустим, у нас есть класс `Rectangle` в нашей системе, который мы хотим использовать как `Shape`, но он не реализует интерфейс `Shape`:

```java
public class Rectangle {
    public void drawRectangle() {
        System.out.println("Drawing a rectangle");
    }
}
```

Чтобы использовать `Rectangle` как `Shape`, мы можем создать адаптер `RectangleAdapter`, который реализует интерфейс `Shape` и делегирует вызовы метода `draw()` объекту `Rectangle`:

```java
public class RectangleAdapter implements Shape {
    private Rectangle rectangle;

    public RectangleAdapter(Rectangle rectangle) {
        this.rectangle = rectangle;
    }

    @Override
    public void draw() {
        rectangle.drawRectangle();
    }
}
```

Теперь мы можем использовать `Rectangle` через адаптер в клиентском коде:

```java
public class Main {
    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle();
        Shape adapter = new RectangleAdapter(rectangle);

        Client client = new Client(adapter);
        client.execute();
    }
}
```

### Отличие от паттерна "Декоратор"

**Описание:**
Паттерн "Декоратор" используется для добавления нового функционала существующим объектам без изменения их структуры. Он расширяет функциональность объекта, оборачивая его в один или несколько декораторов, которые представляют собой тот же интерфейс, что и декорируемый объект.

**Пример отличия:**

В отличие от адаптера, декоратор не изменяет интерфейс декорируемого объекта. Он добавляет новую функциональность, сохраняя тот же интерфейс.

Пример использования декоратора для нашего `Shape`:

```java
// Интерфейс декоратора
public interface ShapeDecorator extends Shape {
    // Декорирующий метод
    void decorate();
}

// Конкретный декоратор
public class RedShapeDecorator implements ShapeDecorator {
    private Shape decoratedShape;

    public RedShapeDecorator(Shape decoratedShape) {
        this.decoratedShape = decoratedShape;
    }

    @Override
    public void draw() {
        decoratedShape.draw();
        // Дополнительная функциональность декоратора
        System.out.println("Border Color: Red");
    }

    @Override
    public void decorate() {
        // Дополнительная функциональность декоратора
        System.out.println("Applying red color decoration");
    }
}
```

### Выводы:

- **Адаптер** используется для совмещения несовместимых интерфейсов, предоставляя альтернативный интерфейс для взаимодействия.
  
- **Декоратор** используется для добавления новой функциональности существующим объектам без изменения их интерфейса.
  
- Оба паттерна могут работать вместе, применяя адаптер для работы с внешними компонентами и декоратор для расширения их функциональности без изменения их интерфейсов.