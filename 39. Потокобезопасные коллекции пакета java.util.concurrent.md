Потокобезопасные коллекции из пакета `java.util.concurrent` представляют собой специальные реализации стандартных коллекций, которые обеспечивают безопасный доступ к данным из нескольких потоков. Они предоставляют механизмы синхронизации, которые позволяют избежать ошибок при параллельном доступе и изменении коллекций. Вот основные потокобезопасные коллекции из этого пакета:

### Основные потокобезопасные коллекции

1. **ConcurrentHashMap**:

   - Реализует интерфейс `ConcurrentMap`.

   - Предоставляет безопасный доступ к данным из нескольких потоков без блокировки всей коллекции.

   - Основные методы:

     - `put(key, value)`: добавляет элемент в коллекцию.

     - `get(key)`: возвращает элемент по ключу.

     - `remove(key)`: удаляет элемент по ключу.

     - `size()`: возвращает количество элементов в коллекции.

   Пример использования:

   ```java

   import java.util.concurrent.ConcurrentHashMap;

   public class ConcurrentHashMapExample {

       public static void main(String[] args) {

           ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

           map.put("one", 1);

           map.put("two", 2);

           map.put("three", 3);

           System.out.println("Map size: " + map.size());

           // Итерация по элементам ConcurrentHashMap

           map.forEach((key, value) -> {

               System.out.println(key + " : " + value);

           });

       }

   }

   ```

2. **CopyOnWriteArrayList**:

   - Реализует интерфейс `List`.

   - Обеспечивает потокобезопасное чтение с помощью копирования массива при изменении.

   - Основные методы:

     - `add(element)`: добавляет элемент в список.

     - `get(index)`: возвращает элемент по индексу.

     - `remove(index)`: удаляет элемент по индексу.

     - `size()`: возвращает размер списка.

   Пример использования:

   ```java

   import java.util.concurrent.CopyOnWriteArrayList;

   public class CopyOnWriteArrayListExample {

       public static void main(String[] args) {

           CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();

           list.add("one");

           list.add("two");

           list.add("three");

           System.out.println("List size: " + list.size());

           // Итерация по элементам CopyOnWriteArrayList

           for (String element : list) {

               System.out.println(element);

           }

       }

   }

   ```

3. **ConcurrentLinkedQueue**:

   - Реализует интерфейс `Queue`.

   - Предоставляет потокобезопасную очередь для добавления и удаления элементов.

   - Основные методы:

     - `offer(element)`: добавляет элемент в очередь.

     - `poll()`: извлекает и удаляет элемент из начала очереди.

     - `peek()`: возвращает элемент из начала очереди без удаления.

     - `size()`: возвращает количество элементов в очереди.

   Пример использования:

   ```java

   import java.util.concurrent.ConcurrentLinkedQueue;

   public class ConcurrentLinkedQueueExample {

       public static void main(String[] args) {

           ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();

           queue.offer("one");

           queue.offer("two");

           queue.offer("three");

           System.out.println("Queue size: " + queue.size());

           // Извлечение итерации элементов ConcurrentLinkedQueue

           while (!queue.isEmpty()) {

               System.out.println(queue.poll());

           }

       }

   }

   ```

### Преимущества потокобезопасных коллекций

- **Безопасность при многопоточном доступе**: Гарантируют корректную работу в многопоточной среде без необходимости в явной синхронизации.

- **Высокая производительность**: Предоставляют эффективные механизмы синхронизации, минимизируя блокировки и конфликты.

- **Удобство использования**: Имеют аналогичный интерфейс и API с стандартными коллекциями из `java.util`, что упрощает переход на потокобезопасные реализации.

Потокобезопасные коллекции из пакета `java.util.concurrent` являются надежным выбором для разработки многопоточных приложений, где безопасность данных и производительность имеют высокий приоритет.