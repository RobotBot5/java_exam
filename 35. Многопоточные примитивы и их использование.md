Многопоточные примитивы в Java представляют собой инструменты для управления выполнением нескольких потоков и синхронизации доступа к общим ресурсам. Они помогают разработчикам создавать безопасные и эффективные многопоточные приложения. Рассмотрим основные многопоточные примитивы и их использование в Java.

### Основные многопоточные примитивы

1. **Synchronized блоки и методы**: Позволяют ограничить доступ к блоку кода или методу только одним потоком одновременно, что обеспечивает безопасность при работе с общими данными.

   Пример использования synchronized блока:

   ```java

   synchronized (lockObject) {

       // критическая секция, доступ к общим данным

   }

   ```

2. **Методы wait() и notify()**: Используются для синхронизации потоков и обмена информацией между ними.

   Пример использования методов wait() и notify():

   ```java

   synchronized (sharedObject) {

       while (!condition) {

           sharedObject.wait(); // ожидание уведомления

       }

       // изменение состояния или передача данных

       sharedObject.notify(); // уведомление других потоков

   }

   ```

3. **ReentrantLock**: Предоставляет более гибкий способ управления блокировками, чем synchronized блоки, включая возможность использования условий и временных блокировок.

   Пример использования ReentrantLock:

   ```java

   ReentrantLock lock = new ReentrantLock();

   lock.lock();

   try {

       // критическая секция, доступ к общим данным

   } finally {

       lock.unlock();

   }

   ```

4. **Condition**: Совместно используется с ReentrantLock для реализации условий ожидания и уведомления.

   Пример использования Condition:

   ```java

   ReentrantLock lock = new ReentrantLock();

   Condition condition = lock.newCondition();

   lock.lock();

   try {

       while (!ready) {

           condition.await(); // ожидание сигнала

       }

       // изменение состояния или передача данных

       condition.signal(); // отправка сигнала другим потокам

   } finally {

       lock.unlock();

   }

   ```

5. **Semaphore**: Позволяет ограничить количество потоков, имеющих доступ к общему ресурсу одновременно.

   Пример использования Semaphore:

   ```java

   Semaphore semaphore = new Semaphore(3); // ограничение доступа до трех потоков

   semaphore.acquire(); // получение разрешения на доступ

   try {

       // критическая секция, доступ к общим данным

   } finally {

       semaphore.release(); // освобождение разрешения

   }

   ```

6. **CountDownLatch**: Позволяет одному или нескольким потокам ждать завершения операций другими потоками.

   Пример использования CountDownLatch:

   ```java

   CountDownLatch latch = new CountDownLatch(1); // ожидание завершения одной операции

   // в одном потоке

   latch.await(); // ожидание завершения

   // в другом потоке

   latch.countDown(); // завершение операции и уведомление других потоков

   ```

### Пример комбинации многопоточных примитивов

```java

import java.util.concurrent.locks.*;

public class Example {

    private final Lock lock = new ReentrantLock();

    private final Condition condition = lock.newCondition();

    private boolean ready = false;

    public void waitForCondition() throws InterruptedException {

        lock.lock();

        try {

            while (!ready) {

                condition.await();

            }

            System.out.println("Condition met, continuing...");

        } finally {

            lock.unlock();

        }

    }

    public void setReady() {

        lock.lock();

        try {

            ready = true;

            condition.signalAll();

        } finally {

            lock.unlock();

        }

    }

    public static void main(String[] args) throws InterruptedException {

        Example example = new Example();

        Thread thread1 = new Thread(() -> {

            try {

                Thread.sleep(1000);

                example.setReady();

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        });

        Thread thread2 = new Thread(() -> {

            try {

                example.waitForCondition();

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        });

        thread2.start();

        thread1.start();

        thread1.join();

        thread2.join();

    }

}

```

В этом примере создаются два потока: `thread1` устанавливает флаг `ready` в `true` через `setReady()`, после чего вызывается `signalAll()` для уведомления ожидающих потоков. В то время как `thread2` ждет, пока условие не станет истинным с помощью `waitForCondition()`.