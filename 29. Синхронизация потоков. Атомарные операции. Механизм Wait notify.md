### Атомарные операции

В Java атомарные операции гарантируют, что операция выполняется целиком без прерываний со стороны других потоков. Это важно для предотвращения состояний гонки при многопоточном доступе к общим данным. В Java для реализации атомарных операций используются различные механизмы, включая `synchronized` блоки, `volatile` переменные и классы из пакета `java.util.concurrent.atomic`.

### Механизм Wait/notify

Механизм `wait/notify` представляет собой способ синхронизации между потоками в Java, который позволяет одному потоку ждать, пока другой поток не выполнит определенные действия. Он базируется на методах `wait()`, `notify()` и `notifyAll()` из класса `Object`.

#### Основные методы:

1. **wait()**:

   - Метод `wait()` заставляет текущий поток ожидать, пока другой поток не вызовет метод `notify()` или `notifyAll()` для того же самого объекта.

2. **notify()**:

   - Метод `notify()` будит один из потоков, ожидающих на том же самом объекте, вызвавшем `wait()`. Какой именно поток будет разбужен, зависит от планировщика потоков и не гарантировано.

3. **notifyAll()**:

   - Метод `notifyAll()` будит все потоки, ожидающие на том же самом объекте, вызвавшем `wait()`. Это обычно используется, когда все потоки должны быть оповещены о изменении состояния.

#### Пример использования Wait/notify:

```java

public class WaitNotifyExample {

    public static void main(String[] args) {

        final Object lock = new Object();

        boolean conditionMet = false;

        Thread thread1 = new Thread(() -> {

            synchronized (lock) {

                while (!conditionMet) {

                    try {

                        System.out.println("Thread 1 is waiting...");

                        lock.wait();

                    } catch (InterruptedException e) {

                        e.printStackTrace();

                    }

                }

                System.out.println("Thread 1 condition is met.");

            }

        });

        Thread thread2 = new Thread(() -> {

            synchronized (lock) {

                // Simulating some work

                try {

                    Thread.sleep(2000);

                } catch (InterruptedException e) {

                    e.printStackTrace();

                }

                conditionMet = true;

                System.out.println("Thread 2 condition set to true.");

                lock.notify();

            }

        });

        thread1.start();

        thread2.start();

    }

}

```

В этом примере `thread1` ждет, пока `conditionMet` не станет `true`. `thread2` устанавливает `conditionMet` в `true` и вызывает `notify()`, чтобы разбудить `thread1`.

### Заключение:

Механизмы атомарных операций и `wait/notify` являются важными инструментами для синхронизации потоков в Java. Использование `wait/notify` требует аккуратности при управлении состоянием потоков и обеспечении правильного порядка выполнения. Он позволяет эффективно организовывать сценарии, где потоки должны синхронизироваться по изменению состояния и ресурсов.