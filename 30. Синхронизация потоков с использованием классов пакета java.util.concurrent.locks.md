В Java пакет `java.util.concurrent.locks` предоставляет более гибкие и мощные механизмы для синхронизации потоков, чем простые `synchronized` блоки. Он включает различные типы блокировок (`Locks`), которые позволяют точно управлять взаимным исключением и управлением доступом к общим ресурсам.

### Основные классы из пакета `java.util.concurrent.locks`:

1. **ReentrantLock**: Это реализация `Lock` интерфейса, которая обеспечивает аналогичную функциональность `synchronized` блоков, но с дополнительными возможностями, такими как:

   - Возможность попытки захвата блокировки без блокирования потока (`tryLock()`).

   - Возможность указать время ожидания при попытке захвата блокировки (`tryLock(long timeout, TimeUnit unit)`).

   - Методы для получения условий (`Condition`), позволяющих потокам ожидать определенного условия перед продолжением работы.

Пример использования `ReentrantLock`:

```java

import java.util.concurrent.locks.Lock;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {

    private static int counter = 0;

    private static Lock lock = new ReentrantLock();

    public static void increment() {

        lock.lock();

        try {

            counter++;

        } finally {

            lock.unlock();

        }

    }

    public static int getCounter() {

        lock.lock();

        try {

            return counter;

        } finally {

            lock.unlock();

        }

    }

    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(() -> {

            for (int i = 0; i < 1000; i++) {

                increment();

            }

        });

        Thread thread2 = new Thread(() -> {

            for (int i = 0; i < 1000; i++) {

                increment();

            }

        });

        thread1.start();

        thread2.start();

        thread1.join();

        thread2.join();

        System.out.println("Counter value: " + getCounter());

    }

}

```

2. **ReentrantReadWriteLock**: Это реализация `ReadWriteLock` интерфейса, которая предоставляет разделяемую блокировку для чтения и эксклюзивную блокировку для записи. Это особенно полезно в случаях, когда чтение данных происходит часто и не изменяет состояние объекта.

Пример использования `ReentrantReadWriteLock`:

```java

import java.util.concurrent.locks.ReadWriteLock;

import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReentrantReadWriteLockExample {

    private static int value = 0;

    private static ReadWriteLock lock = new ReentrantReadWriteLock();

    public static void incrementValue() {

        lock.writeLock().lock();

        try {

            value++;

        } finally {

            lock.writeLock().unlock();

        }

    }

    public static int getValue() {

        lock.readLock().lock();

        try {

            return value;

        } finally {

            lock.readLock().unlock();

        }

    }

    public static void main(String[] args) throws InterruptedException {

        Thread writerThread = new Thread(() -> {

            for (int i = 0; i < 1000; i++) {

                incrementValue();

            }

        });

        Thread readerThread = new Thread(() -> {

            for (int i = 0; i < 100; i++) {

                System.out.println("Value read: " + getValue());

                try {

                    Thread.sleep(10);

                } catch (InterruptedException e) {

                    e.printStackTrace();

                }

            }

        });

        writerThread.start();

        readerThread.start();

        writerThread.join();

        readerThread.join();

    }

}

```

### Преимущества использования классов из `java.util.concurrent.locks`:

- **Гибкость и контроль**: Возможность использовать разные типы блокировок в зависимости от потребностей приложения.

- **Улучшенная производительность**: Реализация, такая как `ReentrantLock`, предлагает более эффективное управление блокировками в сравнении с примитивными `synchronized` блоками.

- **Поддержка условий**: Возможность использовать условия для ожидания и уведомления в более сложных сценариях синхронизации.

Использование классов из `java.util.concurrent.locks` рекомендуется при разработке высокопроизводительных и многопоточных приложений, где требуется более гибкая и точная синхронизация между потоками.