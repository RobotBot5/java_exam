В Java пакет `java.util.concurrent.locks` предоставляет более гибкие и мощные механизмы для синхронизации потоков, чем простые `synchronized` блоки. Он включает различные типы блокировок (`Locks`), которые позволяют точно управлять взаимным исключением и управлением доступом к общим ресурсам.

### Основные классы из пакета `java.util.concurrent.locks`:

 - **Повторное вхождение (Reentrancy):**
    
    - Как и `synchronized`, `ReentrantLock` поддерживает повторное вхождение (рекурсивную блокировку). Это означает, что один и тот же поток может многократно захватывать и освобождать блокировку без блокировки самого себя.
- **Методы для управления блокировкой:**
    
    - `lock()`: Блокирует доступ к критическому ресурсу. Если ресурс уже заблокирован другим потоком, текущий поток блокируется до тех пор, пока не сможет получить блокировку.
    - `unlock()`: Освобождает блокировку. Должен вызываться в конце работы с критическим ресурсом для разблокировки доступа.
- **Дополнительные возможности:**
    
    - `tryLock()`: Пытается захватить блокировку. Возвращает `true`, если блокировка была успешно захвачена текущим потоком, иначе возвращает `false`, если блокировка не доступна.
    - `tryLock(long timeout, TimeUnit unit)`: Пытается захватить блокировку в течение указанного времени. Если блокировка не была захвачена в течение указанного периода, метод возвращает `false`.
    - `newCondition()`: Возвращает новый объект `Condition`, который связан с этой блокировкой. Условия (`Condition`) позволяют потокам ожидать определенных условий перед продолжением работы.

Пример использования `ReentrantLock`:

```java

import java.util.concurrent.locks.Lock;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {

    private static int counter = 0;

    private static Lock lock = new ReentrantLock();

    public static void increment() {

        lock.lock();

        try {

            counter++;

        } finally {

            lock.unlock();

        }

    }

    public static int getCounter() {

        lock.lock();

        try {

            return counter;

        } finally {

            lock.unlock();

        }

    }

    public static void main(String[] args) throws InterruptedException {

        Thread thread1 = new Thread(() -> {

            for (int i = 0; i < 1000; i++) {

                increment();

            }

        });

        Thread thread2 = new Thread(() -> {

            for (int i = 0; i < 1000; i++) {

                increment();

            }

        });

        thread1.start();

        thread2.start();

        thread1.join();

        thread2.join();

        System.out.println("Counter value: " + getCounter());

    }

}

```


2. `ReentrantReadWriteLock` является реализацией интерфейса `ReadWriteLock`, который предоставляет механизм разделяемой блокировки для чтения и эксклюзивной блокировки для записи. Это означает, что он позволяет нескольким потокам одновременно читать данные (разделяемый доступ), но позволяет только одному потоку писать данные (эксклюзивный доступ).

### Особенности ReentrantReadWriteLock:

1. **Разделяемая блокировка для чтения:**
    
    - Потоки могут одновременно владеть разделяемой блокировкой для чтения, если они только читают данные и не изменяют их. Это позволяет увеличить параллелизм и эффективность в приложениях, где чтение данных происходит намного чаще, чем их изменение.
2. **Эксклюзивная блокировка для записи:**
    
    - Только один поток может владеть эксклюзивной блокировкой для записи. Это обеспечивает защиту данных от конкурентного изменения и поддерживает целостность данных в случае модификации.
3. **Повторное вхождение (Reentrancy):**
    
    - Как и в случае с `ReentrantLock`, `ReentrantReadWriteLock` поддерживает повторное вхождение. Это означает, что один поток может многократно захватывать разделяемую или эксклюзивную блокировку, пока не разблокирует её соответствующим количеством вызовов `unlock()`.
4. **Методы блокировки:**
    
    - `readLock()`: Возвращает объект блокировки для чтения. Потоки могут захватывать эту блокировку для параллельного чтения данных.
    - `writeLock()`: Возвращает объект блокировки для записи. Только один поток может захватить эту блокировку для изменения данных.

Пример использования `ReentrantReadWriteLock`:

```java

import java.util.concurrent.locks.ReadWriteLock;

import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReentrantReadWriteLockExample {

    private static int value = 0;

    private static ReadWriteLock lock = new ReentrantReadWriteLock();

    public static void incrementValue() {

        lock.writeLock().lock();

        try {

            value++;

        } finally {

            lock.writeLock().unlock();

        }

    }

    public static int getValue() {

        lock.readLock().lock();

        try {

            return value;

        } finally {

            lock.readLock().unlock();

        }

    }

    public static void main(String[] args) throws InterruptedException {

        Thread writerThread = new Thread(() -> {

            for (int i = 0; i < 1000; i++) {

                incrementValue();

            }

        });

        Thread readerThread = new Thread(() -> {

            for (int i = 0; i < 100; i++) {

                System.out.println("Value read: " + getValue());

                try {

                    Thread.sleep(10);

                } catch (InterruptedException e) {

                    e.printStackTrace();

                }

            }

        });

        writerThread.start();

        readerThread.start();

        writerThread.join();

        readerThread.join();

    }

}

```

### Преимущества использования классов из `java.util.concurrent.locks`:

- **Гибкость и контроль**: Возможность использовать разные типы блокировок в зависимости от потребностей приложения.

- **Улучшенная производительность**: Реализация, такая как `ReentrantLock`, предлагает более эффективное управление блокировками в сравнении с примитивными `synchronized` блоками.

- **Поддержка условий**: Возможность использовать условия для ожидания и уведомления в более сложных сценариях синхронизации.

Использование классов из `java.util.concurrent.locks` рекомендуется при разработке высокопроизводительных и многопоточных приложений, где требуется более гибкая и точная синхронизация между потоками.