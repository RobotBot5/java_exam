В Java, класс `Thread` предоставляет множество методов для управления потоками. Эти методы позволяют контролировать жизненный цикл потока, его приоритет, состояние, выполнение и другие аспекты. Давайте рассмотрим основные методы класса `Thread`:

### Основные методы класса `Thread`:

1. **start()**

   - Метод `start()` запускает новый поток выполнения, вызывая метод `run()`. Он инициирует выполнение потока, но не вызывает `run()` напрямую.

   ```java

   Thread thread = new Thread(() -> {

       System.out.println("Thread is running.");

   });

   thread.start(); // Запуск потока

   ```

2. **run()**

   - Метод `run()` содержит код, который будет выполняться в потоке. Для запуска потока необходимо использовать метод `start()`.

   ```java

   Thread thread = new Thread(() -> {

       System.out.println("Thread is running.");

   });

   thread.start(); // Запуск потока

   ```

3. **join()**

   - Метод `join()` блокирует текущий поток выполнения до тех пор, пока поток, на котором он вызван, не завершится.

   ```java

   Thread thread = new Thread(() -> {

       System.out.println("Thread is running.");

   });

   thread.start(); // Запуск потока

   try {

       thread.join(); // Ожидание завершения потока

   } catch (InterruptedException e) {

       e.printStackTrace();

   }

   System.out.println("Thread has finished.");

   ```

4. **sleep(long millis)**

   - Метод `sleep()` заставляет текущий поток приостановить свое выполнение на указанное количество миллисекунд.

   ```java

   Thread thread = new Thread(() -> {

       try {

           Thread.sleep(1000); // Поток приостанавливается на 1 секунду

       } catch (InterruptedException e) {

           e.printStackTrace();

       }

       System.out.println("Thread woke up.");

   });

   thread.start(); // Запуск потока

   ```

5. **interrupt()**

   - Метод `interrupt()` отправляет сигнал потоку, что он должен завершить свою работу. Он устанавливает флаг прерывания у потока.

   ```java

   Thread thread = new Thread(() -> {

       while (!Thread.currentThread().isInterrupted()) {

           System.out.println("Thread is running.");

           try {

               Thread.sleep(1000);

           } catch (InterruptedException e) {

               Thread.currentThread().interrupt(); // Установка флага прерывания

           }

       }

       System.out.println("Thread has finished.");

   });

   thread.start(); // Запуск потока

   // Прерываем поток через 3 секунды

   try {

       Thread.sleep(3000);

       thread.interrupt(); // Прерывание потока

   } catch (InterruptedException e) {

       e.printStackTrace();

   }

   ```

6. **isAlive()**

   - Метод `isAlive()` проверяет, выполняется ли поток. Возвращает `true`, если поток запущен и не завершен, и `false`, если поток либо еще не запущен, либо уже завершен.

   ```java

   Thread thread = new Thread(() -> {

       System.out.println("Thread is running.");

   });

   thread.start(); // Запуск потока

   System.out.println("Is thread alive? " + thread.isAlive());

   ```

7. **setName(String name) и getName()**

   - Методы `setName()` и `getName()` используются для установки и получения имени потока.

   ```java

   Thread thread = new Thread(() -> {

       System.out.println("Thread is running.");

   });

   thread.setName("MyThread");

   System.out.println("Thread name: " + thread.getName());

   ```

8. **setPriority(int priority) и getPriority()**

   - Методы `setPriority()` и `getPriority()` используются для установки и получения приоритета потока.

   ```java

   Thread thread = new Thread(() -> {

       System.out.println("Thread is running.");

   });

   thread.setPriority(Thread.MAX_PRIORITY); // Установка максимального приоритета

   System.out.println("Thread priority: " + thread.getPriority());

   ```

### Заключение:

Методы класса `Thread` предоставляют мощные средства управления потоками в Java. Они позволяют запускать потоки, ожидать их завершения, управлять приостановкой и прерыванием выполнения, а также устанавливать различные параметры потоков, такие как имя и приоритет. Правильное использование этих методов позволяет эффективно управлять многопоточностью в Java при разработке приложений.