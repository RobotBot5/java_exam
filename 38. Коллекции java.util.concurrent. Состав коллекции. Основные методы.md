Коллекции из пакета `java.util.concurrent` предназначены для использования в многопоточных приложениях и предлагают более безопасные альтернативы стандартным коллекциям из пакета `java.util`. Они предоставляют различные механизмы синхронизации и безопасности для работы с общими данными из нескольких потоков. Рассмотрим основные коллекции и их методы.

### Основные коллекции из `java.util.concurrent`

1. **ConcurrentHashMap**:

   - Реализует интерфейс `ConcurrentMap`.

   - Предоставляет безопасный доступ к данным из нескольких потоков без блокировки всей коллекции.

   - Основные методы:

     - `put(key, value)`: добавляет элемент в коллекцию.

     - `get(key)`: возвращает элемент по ключу.

     - `remove(key)`: удаляет элемент по ключу.

     - `size()`: возвращает количество элементов в коллекции.

2. **CopyOnWriteArrayList**:

   - Реализует интерфейс `List`.

   - Обеспечивает потокобезопасное чтение с помощью копирования массива при изменении.

   - Основные методы:

     - `add(element)`: добавляет элемент в список.

     - `get(index)`: возвращает элемент по индексу.

     - `remove(index)`: удаляет элемент по индексу.

     - `size()`: возвращает размер списка.

3. **ConcurrentLinkedQueue**:

   - Реализует интерфейс `Queue`.

   - Предоставляет потокобезопасную очередь для добавления и удаления элементов.

   - Основные методы:

     - `offer(element)`: добавляет элемент в очередь.

     - `poll()`: извлекает и удаляет элемент из начала очереди.

     - `peek()`: возвращает элемент из начала очереди без удаления.

     - `size()`: возвращает количество элементов в очереди.

4. **BlockingQueue (например, ArrayBlockingQueue)**:

   - Реализует интерфейс `BlockingQueue`.

   - Предоставляет блокирующую очередь, где потоки могут блокироваться при попытке выполнить операции, когда очередь пуста или полна.

   - Основные методы:

     - `put(element)`: добавляет элемент в очередь, блокируется при полной очереди.

     - `take()`: извлекает и удаляет элемент из очереди, блокируется при пустой очереди.

     - `offer(element, timeout, unit)`: добавляет элемент в очередь с таймаутом.

     - `poll(timeout, unit)`: извлекает элемент из очереди с таймаутом.

### Пример использования ConcurrentHashMap:

```java

import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {

    public static void main(String[] args) {

        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

        map.put("one", 1);

        map.put("two", 2);

        map.put("three", 3);

        System.out.println("Map size: " + map.size());

        // Итерация по элементам ConcurrentHashMap

        map.forEach((key, value) -> {

            System.out.println(key + " : " + value);

        });

    }

}

```

Этот пример создает `ConcurrentHashMap`, добавляет несколько элементов, выводит размер карты и итерирует по элементам с помощью метода `forEach()`.

Коллекции из `java.util.concurrent` предоставляют надежные инструменты для управления общими данными в многопоточных приложениях, обеспечивая безопасность и эффективность работы с потоками.