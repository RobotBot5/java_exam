Пример с использованием синхронизации потоков для пары процессов "производитель-потребитель" (producer-consumer) демонстрирует типичную задачу, где один поток (производитель) создает данные, а другой поток (потребитель) потребляет эти данные. Важно обеспечить синхронизированный доступ к общему ресурсу (буферу), чтобы избежать гонки данных и некорректного доступа.

### Пример с использованием синхронизации для производителя и потребителя:

```java

import java.util.LinkedList;

import java.util.Queue;

class ProducerConsumer {

    private Queue<Integer> buffer = new LinkedList<>();

    private final int CAPACITY = 5;

    public void produce() throws InterruptedException {

        int value = 0;

        while (true) {

            synchronized (this) {

                while (buffer.size() >= CAPACITY) {

                    wait(); // Ждем, пока потребитель не заберет данные

                }

                System.out.println("Producer produced: " + value);

                buffer.add(value++);

                notify(); // Сообщаем потребителю, что появились данные

                Thread.sleep(1000); // Эмулируем процесс производства

            }

        }

    }

    public void consume() throws InterruptedException {

        while (true) {

            synchronized (this) {

                while (buffer.isEmpty()) {

                    wait(); // Ждем, пока производитель не добавит данные

                }

                int value = buffer.poll();

                System.out.println("Consumer consumed: " + value);

                notify(); // Сообщаем производителю, что освободилось место

                Thread.sleep(1000); // Эмулируем процесс потребления

            }

        }

    }

}

public class Main {

    public static void main(String[] args) {

        ProducerConsumer pc = new ProducerConsumer();

        Thread producerThread = new Thread(() -> {

            try {

                pc.produce();

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        });

        Thread consumerThread = new Thread(() -> {

            try {

                pc.consume();

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        });

        producerThread.start();

        consumerThread.start();

    }

}

```

### Объяснение примера:

1. **ProducerConsumer класс:**

   - `buffer` представляет собой общий ресурс (очередь), куда производитель добавляет данные, а потребитель их забирает.

   - `CAPACITY` определяет максимальный размер буфера.

   - Метод `produce()` добавляет элементы в буфер.

   - Метод `consume()` удаляет элементы из буфера.

2. **Метод `produce()`:**

   - Синхронизирован по текущему объекту (`this`), что позволяет только одному потоку выполнить блок синхронизации одновременно.

   - Используется `wait()` для приостановки потока, если буфер заполнен, и `notify()` для оповещения потребителя после добавления элемента в буфер.

3. **Метод `consume()`:**

   - Также синхронизирован по текущему объекту.

   - Используется `wait()` для приостановки потока, если буфер пуст, и `notify()` для оповещения производителя после извлечения элемента из буфера.

4. **Main класс:**

   - Создает экземпляр `ProducerConsumer`.

   - Запускает два потока: один для производителя (`producerThread`), другой для потребителя (`consumerThread`).

### Заключение:

Этот пример демонстрирует, как с использованием синхронизации и методов `wait()` и `notify()` можно эффективно реализовать паттерн "производитель-потребитель" в многопоточной среде Java. Синхронизация по текущему объекту (`this`) гарантирует правильный доступ к общему ресурсу (буферу) и предотвращает возникновение гонки данных, что важно для корректной работы многопоточных приложений.