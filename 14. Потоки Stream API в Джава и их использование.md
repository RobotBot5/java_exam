Потоки (Streams) в Java Stream API представляют собой мощный инструмент для работы с коллекциями объектов или другими источниками данных. Они позволяют выполнять различные операции над данными, такие как фильтрация, сортировка, отображение, агрегация и другие, с использованием функционального стиля программирования. Введённые в Java 8, потоки предоставляют более удобный и эффективный способ работы с данными по сравнению с традиционными циклами и операциями над коллекциями.

### Основные особенности и возможности потоков Stream API:

1. **Источники данных**:

   - Потоки могут быть созданы из коллекций, массивов, файлов, числовых последовательностей и других источников данных.

2. **Промежуточные операции**:

   - Это операции, которые выполняются над элементами потока и возвращают новый поток. Примеры: фильтрация (`filter`), отображение (`map`), сортировка (`sorted`), ограничение (`limit`), пропуск (`skip`) и другие.

3. **Терминальные операции**:

   - Это операции, завершающие работу с потоком и возвращающие результат. Примеры: сборка элементов в коллекцию (`collect`), вычисление суммы (`sum`), нахождение минимума или максимума (`min`/`max`), проверка на соответствие предикату (`anyMatch`, `allMatch`, `noneMatch`) и другие.

4. **Параллельные потоки**:

   - Потоки могут быть выполнены параллельно, что позволяет использовать мощности многоядерных процессоров для ускорения обработки данных. Для этого можно вызвать метод `parallel()` на потоке или использовать параллельные версии операций, такие как `parallelStream()`.

### Примеры использования потоков Stream API:

#### Пример 1: Фильтрация и сортировка коллекции чисел

```java

import java.util.Arrays;

import java.util.List;

import java.util.stream.Collectors;

public class StreamExample {

    public static void main(String[] args) {

        List<Integer> numbers = Arrays.asList(1, 3, 7, 2, 10, 4, 6, 8, 5);

        // Фильтрация чисел больше 5 и их сортировка

        List<Integer> filteredAndSorted = numbers.stream()

                                                .filter(n -> n > 5)

                                                .sorted()

                                                .collect(Collectors.toList());

        System.out.println("Filtered and sorted numbers: " + filteredAndSorted);

    }

}

```

#### Пример 2: Преобразование строк в верхний регистр

```java

import java.util.Arrays;

import java.util.List;

import java.util.stream.Collectors;

public class StreamExample {

    public static void main(String[] args) {

        List<String> words = Arrays.asList("apple", "banana", "orange", "grape", "pineapple");

        // Преобразование строк в верхний регистр

        List<String> upperCaseWords = words.stream()

                                          .map(String::toUpperCase)

                                          .collect(Collectors.toList());

        System.out.println("Words in upper case: " + upperCaseWords);

    }

}

```

#### Пример 3: Параллельная обработка потока

```java

import java.util.Arrays;

import java.util.List;

import java.util.stream.Collectors;

public class StreamExample {

    public static void main(String[] args) {

        List<Integer> numbers = Arrays.asList(1, 3, 7, 2, 10, 4, 6, 8, 5);

        // Параллельная фильтрация и сортировка чисел больше 5

        List<Integer> parallelFilteredAndSorted = numbers.parallelStream()

                                                        .filter(n -> n > 5)

                                                        .sorted()

                                                        .collect(Collectors.toList());

        System.out.println("Parallel filtered and sorted numbers: " + parallelFilteredAndSorted);

    }

}

```

### Заключение:

Потоки Stream API в Java предоставляют мощный и удобный способ обработки и манипуляции данными. Они позволяют писать более чистый и компактный код, способствуют повышению производительности за счёт параллельной обработки и упрощают работу с коллекциями и другими данными. Использование Stream API стало одним из ключевых аспектов функционального программирования в Java.